<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta content="width=device-width, initial-scale=1" name="viewport"/>
		<meta content="Explains how to use Sinobu and its API. " name="description"/>
		<link href="https://cdn.jsdelivr.net" rel="preconnect"/>
		<link href="https://fonts.googleapis.com" rel="preconnect"/>
		<link crossorigin="null" href="https://fonts.gstatic.com" rel="preconnect"/>
		<link as="style" fetchpriority="high" href="https://fonts.googleapis.com/css2?display=swap&#38;family=Inter" rel="preload"/>
		<link href="https://fonts.googleapis.com/css2?display=swap&#38;family=Inter" media="print" onload="this.media=&#39;all&#39;" rel="stylesheet"/>
		<link as="style" fetchpriority="high" href="https://fonts.googleapis.com/css2?display=swap&#38;family=Material+Icons" rel="preload"/>
		<link href="https://fonts.googleapis.com/css2?display=swap&#38;family=Material+Icons" media="print" onload="this.media=&#39;all&#39;" rel="stylesheet"/>
		<link as="style" fetchpriority="high" href="https://fonts.googleapis.com/css2?display=swap&#38;family=Vollkorn" rel="preload"/>
		<link href="https://fonts.googleapis.com/css2?display=swap&#38;family=Vollkorn" media="print" onload="this.media=&#39;all&#39;" rel="stylesheet"/>
		<title>Sinobu API</title>
		<base href="../"/>
		<script src="mimic.js" type="module"></script>
		<link href="https://cdn.jsdelivr.net/npm/ress@4.0.0/dist/ress.min.css" rel="stylesheet"/>
		<link href="main.css" rel="stylesheet"/>
	</head>
	<body class="d">
		<header class="V" date="2024-11-18" ver="4.5.2">
			<h1 class="W"><code>Sinobu</code></h1>
			<nav class="M"><a href="doc/doc.DocumentDoc.Introduction.html"><svg class="text A svg" viewBox="0 0 24 24">
						<use href="main.svg#text"/>
					</svg>Document</a><a href="api/" id="API"><svg class="package A svg" viewBox="0 0 24 24">
						<use href="main.svg#package"/>
					</svg>
				</a><a href="https://github.com/teletha/sinobu/discussions" id="Community" target="_blank"><svg class="user A svg" viewBox="0 0 24 24">
						<use href="main.svg#user"/>
					</svg>
				</a><a href="doc/changelog.html" id="Activity"><svg class="activity A svg" viewBox="0 0 24 24">
						<use href="main.svg#activity"/>
					</svg>
				</a><a href="https://github.com/teletha/sinobu" id="Repository" target="_blank"><svg class="github A svg" viewBox="0 0 24 24">
						<use href="main.svg#github"/>
					</svg>
				</a></nav>
			<div class="X"><a aria-label="Change color scheme" id="theme"><svg class="sun A svg" viewBox="0 0 24 24">
						<use href="main.svg#sun"/>
					</svg><svg class="moon A svg" viewBox="0 0 24 24">
						<use href="main.svg#moon"/>
					</svg>
				</a></div>
		</header>
		<nav class="c"></nav>
		<article class="e" id="Article">
			<div class="s">
				<section class="B" id="doc.DocumentDoc.Dependency_Injection.Concept">
					<header class="B b">
						<h2>Concept</h2>
						<div class="n"><span class="perp S"><svg class="copy A svg" viewBox="0 0 24 24">
									<use href="main.svg#copy"/>
								</svg>
							</span><a class="tweet S"><svg class="twitter A svg" viewBox="0 0 24 24">
									<use href="main.svg#twitter"/>
								</svg>
							</a><a class="edit S" href="https://github.com/teletha/sinobu/edit/master/src/test/java/doc/DocumentDoc.java#L286-L295"><svg class="edit A svg" viewBox="0 0 24 24">
									<use href="main.svg#edit"/>
								</svg>
							</a></div>
					</header><span class="B"><p>Dependency Injection (DI) is a mechanism that solves various problems related to
component dependencies in &#39;a nice way&#39;. Component dependency refers to the relationship
from upper layer to lower layer, such as Controller â†’ Service â†’ Repository in a general
layered architecture.
&#39;A nice way&#39; means that the framework will take care of the problem without the developer
having to work hard manually.</p><p>In modern Java application development, DI is an almost indispensable mechanism.
The detailed explanation of the DI concept is left to <a href="https://en.wikipedia.org/wiki/Dependency_injection">another
website</a>.</p></span></section>
				<section class="B l" id="doc.DocumentDoc.Dependency_Injection.Concept.DI_Container">
					<header class="B p">
						<h3>DI Container</h3>
					</header><span class="B"><p>Unlike other DI frameworks, there is no explicit DI container in Sinobu. It has only
one container implicitly inside, but the user is not aware of it. Therefore, there is
also no need to define dependencies explicitly by means of code or external files.
All dependencies are automatically resolved based on type.</p></span></section>
				<section class="B l" id="doc.DocumentDoc.Dependency_Injection.Concept.Injection_Type">
					<header class="B p">
						<h3>Injection Type</h3>
					</header><span class="B"><p>Commonly, there are four main types in which a client can receive injected services.</p><ul>
							<li>Constructor injection, where dependencies are provided through a client&#39;s class
constructor.</li>
							<li>Setter injection, where the client exposes a setter method which accepts the
dependency.</li>
							<li>Field injection, where the client exposes a field which accepts the dependency.</li>
							<li>Interface injection, where the dependency&#39;s interface provides an injector method
that will inject the dependency into any client passed to it.</li>
						</ul><p>Of these, <strong>only constructor injection is supported</strong> by Sinobu. Other injection
types will <strong>not be supported in the future</strong> due to their significant disruption
to object safety.</p></span></section>
			</div>
			<div class="s">
				<section class="B" id="doc.DocumentDoc.Dependency_Injection.Constructor_Injection">
					<header class="B b">
						<h2>Constructor Injection</h2>
						<div class="n"><span class="perp S"><svg class="copy A svg" viewBox="0 0 24 24">
									<use href="main.svg#copy"/>
								</svg>
							</span><a class="tweet S"><svg class="twitter A svg" viewBox="0 0 24 24">
									<use href="main.svg#twitter"/>
								</svg>
							</a><a class="edit S" href="https://github.com/teletha/sinobu/edit/master/src/test/java/doc/DocumentDoc.java#L328-L332"><svg class="edit A svg" viewBox="0 0 24 24">
									<use href="main.svg#edit"/>
								</svg>
							</a></div>
					</header><span class="B"><p>The most common form of dependency injection is for a class to request its
dependencies through its constructor. This ensures the client is always in a valid
state, since it cannot be instantiated without its necessary dependencies.</p><pre class="lang-java"><code>public void objectInjection() {
    class Injectable {
    }

    class Injection {
        private Injectable value;

        Injection(Injectable injectable) {
            this.value = injectable;
        }
    }

    assert I.make(Injection.class).value != null;
}</code></pre></span></section>
				<section class="B l" id="doc.DocumentDoc.Dependency_Injection.Constructor_Injection.Injectable_Type">
					<header class="B p">
						<h3>Injectable Type</h3>
					</header><span class="B"><p>Any type can be injectable, but there are a few types that receive special treatment.</p><ul>
							<li>Primitives - A default value (0 for int, false for boolean) is assigned.</li>
						</ul><pre class="lang-java"><code>public void primitiveIntInjection() {
    class Injection {
        private int value;

        Injection(int injectable) {
            this.value = injectable;
        }
    }

    assert I.make(Injection.class).value == 0;
}</code></pre><pre class="lang-java"><code>public void primitiveBooleanInjection() {
    class Injection {
        private boolean value;

        Injection(boolean injectable) {
            this.value = injectable;
        }
    }

    assert I.make(Injection.class).value == false;
}</code></pre><ul>
							<li><code><a aria-label="kiss.Lifestyle" href="api/kiss.Lifestyle.html">Lifestyle</a></code> - The resolution of dependencies can be delayed until the user
actually needs it. Type variables must be correctly specified.</li>
						</ul><pre class="lang-java"><code>public void objectLazyInjection() {
    class Injection {
        private Lifestyle&#60;Person&#62; lazy;

        Injection(Lifestyle&#60;Person&#62; injectable) {
            this.lazy = injectable;
        }
    }

    assert I.make(Injection.class).lazy.get() != null;
}</code></pre><ul>
							<li><code><a aria-label="java.lang.Class ðŸš€" href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Class.html">Class</a></code> - The currently processing model type. This feature is mainly
available when implementing the special generic <code><a aria-label="kiss.Lifestyle" href="api/kiss.Lifestyle.html">Lifestyle</a></code>.</li>
						</ul><pre class="lang-java"><code>public void typeInjection() {
    class Injection {
        private Class type;

        Injection(Class injectable) {
            this.type = injectable;
        }
    }

    assert I.make(Injection.class).type == null;
}</code></pre></span></section>
				<section class="B l" id="doc.DocumentDoc.Dependency_Injection.Constructor_Injection.Priority">
					<header class="B p">
						<h3>Priority</h3>
					</header><span class="B"><p>If only one constructor is defined for the class being injected, it is used. If more
than one constructor is defined, it must detect which constructor is to be used.</p><p>The constructor with the <code><a aria-label="kiss.Managed" href="api/kiss.Managed.html">Managed</a></code> annotation has the highest priority.</p><pre class="lang-java"><code>public void priorityManaged() {
    class Injection {

        private int value;

        Injection() {
            value = 10;
        }

        // This constructore is used.
        @Managed
        Injection(int injectable) {
            this.value = injectable;
        }
    }

    assert I.make(Injection.class).value == 0;
}</code></pre><p>Next priority is given to constructors with the Inject annotation. The Inject
annotation targets all annotations with the simple name &#39;Inject&#39;, so annotations such
as jakarta.inject.Inject used in JSR330 etc. can also be used.</p><pre class="lang-java"><code>public void priorityInject() {
    class Injection {

        private int value;

        Injection() {
            value = 10;
        }

        // This constructore is used.
        @Inject
        Injection(int injectable) {
            this.value = injectable;
        }
    }

    assert I.make(Injection.class).value == 0;
}</code></pre><p>If no annotation is found, the constructor with the lowest number of arguments is
used.</p><pre class="lang-java"><code>public void priorityMinParam() {
    class Injection {

        private int value;

        // This constructore is used.
        Injection() {
            value = 10;
        }

        Injection(int injectable) {
            this.value = injectable;
        }
    }

    assert I.make(Injection.class).value == 10;
}</code></pre><p>If several constructors with the smallest number of arguments are defined, the first
constructor found among them is used. (which is implementation-dependent in the JDK)</p><pre class="lang-java"><code>public void priorityMinParams() {
    class Injection {

        private int value;

        // This constructore is used.
        Injection(boolean injectable) {
            value = injectable ? 1 : 10;
        }

        Injection(int injectable) {
            this.value = injectable;
        }
    }

    assert I.make(Injection.class).value == 10;
}</code></pre></span></section>
				<section class="B l" id="doc.DocumentDoc.Dependency_Injection.Constructor_Injection.Circular_Reference">
					<header class="B p">
						<h3>Circular Reference</h3>
					</header><span class="B"><p>One of the problems with constructor injection is that it cannot resolve circular
dependencies. To partially solve this problem, Sinobu provides a delayed dependency
injection method, but it does not completely solve any situation. If a solution is
not possible, an error will occur.</p><pre class="lang-java"><code>public static class CircularLifestyleA {

    private Lifestyle&#60;CircularLifestyleB&#62; other;

    private CircularLifestyleA(Lifestyle&#60;CircularLifestyleB&#62; other) {
        this.other = other;
    }
}</code></pre><pre class="lang-java"><code>public static class CircularLifestyleB {

    private Lifestyle&#60;CircularLifestyleA&#62; other;

    private CircularLifestyleB(Lifestyle&#60;CircularLifestyleA&#62; other) {
        this.other = other;
    }
}</code></pre><pre class="lang-java"><code>public void circularDependenciesWithProvider() {
    CircularLifestyleA circularA = I.make(CircularLifestyleA.class);
    assert circularA.other != null;

    CircularLifestyleB circularB = I.make(CircularLifestyleB.class);
    assert circularB.other != null;
}</code></pre></span></section>
			</div>
		</article>
		<aside class="U"></aside>
		<footer class="Q"/>
	</body>
	<script src="root.js"></script>
	<script src="main.js" type="module"></script>
</html>